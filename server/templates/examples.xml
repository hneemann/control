<?xml version="1.0" encoding="UTF-8"?>
<Examples>
    <example name="Daten-Plot">let data = [
  [0, 0],
  [1, 1],
  [2, 4],
  [3, 9],
  [4,16]
];

plot(
 scatter( data )
)</example>
    <example name="Graph" desc="Funktionsplot">plot(
 function( x->sin(pi*x) )
)</example>
    <example name="Graph 2" desc="Funktionsplotter">plot(
 function( x->sin(pi*x), black, "sin(x)"),
 function( x->cos(pi*x), blue,  "cos(x)")
).xBounds(0,2).grid()</example>
    <example name="Ortskurve" desc="Darstellung der Ortskurve">let s = lin();
let g = 3/((s+1)*(s+2));

g.nyquist()</example>
    <example name="Ortskurve 2" desc="Darstellung der Ortskurve">let s = lin();
let g = 3/((s+1)*(s+1.5)*(s+2));

func h(w)
  let c = g( cplx(0,w) );
  hint(c.real(),c.imag(),"Ï‰="+w,black,2);

g.nyquist()
  .add( h(0.1)  )
  .add( h(0.25) )
  .add( h(0.5)  )
  .add( h(1)    )
  .add( h(2)    )</example>
    <example name="Nyquist" desc="Anwendung des Nyquistkriteriums">let s = lin();
let g = 6*(s+1)/((s-1)*(s-3));

g.nyquist(true)</example>
    <example name="Bode" desc="Darstellung eines Bode-Diagramms">let s = lin();
let g = 3/((s+1)*(s+2));

bode(0.01,100)
  .add(g)</example>
    <example name="Bode 2" desc="Darstellung mehrerer Kurven in einem Bode-Diagramm">let s = lin();
let g = 3/((s+1)*(s+2));
let k = 1.5*(1+1/(2.5*s));

bode(0.01,100)
  .add(g,   green, "G")
  .add(k,   blue,  "K")
  .add(k*g, black, "G0")</example>
    <example name="pid" desc="Die pid-Funktion">[
 ["pid(2,2)",   "=", pid(2,2)  ],
 ["pid(2,3,1)", "=", pid(2,3,1)]
]</example>
    <example name="WOK" desc="Darstellung einer Wurzelortskurve">let s = lin();
let g = 3/((s+1)*(s+2));
let k = 1+1/(0.9*s);

(k*g).evans(2)</example>

    <example name="Simulation" desc="Simulation des Systems">let s=lin();

let g=70/((s+1)*(s+2)*(s+2.5));
let k=0.2*(0.6*s+1)/(0.002*s+1);
let k2=pid(0.09,2);
let k3=pid(0.3,2,0.5);

plot(
  curve((k*g).loop().simStep(10),blue,"phasenanhebendes Korrekturglied"),
  curve((k2*g).loop().simStep(10),black,"PI"),
  curve((k3*g).loop().simStep(10),green,"PID")
).xLabel("t").yLabel("h(t)").labelPos(5,0.87)</example>

        <example name="Simulation 2" desc="Simulation des Systems">func generateCalc(T,d)
  t->if t&lt;0 then 0
            else
              let w0=1/T;
              let we=w0*sqrt(1-d*d);
              let phi=acos(d);
              1-exp(-w0*d*t)/sqrt(1-d*d)*sin(we*t+phi);

let s =lin();
func generateSim(T,d)
  let g=1/(T*T*s^2+2*T*d*s+1);
  g.simStep(40);

plot(
 function( generateCalc(1,0.1), black, "calc"),
 curve(    generateSim(1,0.1),  red,   "sim")
)</example>

            <example name="Nelder&amp;Mead" desc="Nichtlineare Optimierung">let s = lin();
let g=70/((s+1)*(s+2)*(s+2.5));

func getSim(kp,Ti,Td)
  (pid(kp,Ti,Td)*g).loop().simStep(10);

func targetMax(kp,Ti,Td)
  let sim=getSim(kp,Ti,Td);
  abs(sim.minMax(e->e[1]).max-1.04);

func targetTime(kp,Ti,Td)
  let sim=getSim(kp,Ti,Td);
  let line=sim.combine((a,b)->{a:a,b:b}).accept(e->abs(e.a[1]-1)>0.04 &amp; abs(e.b[1]-1)&lt;=0.04).last();
  line.a[0]+(1-line.a[1])/(line.b[1]-line.a[1])*(line.b[0]-line.a[0]);

func getCurve(kp,Ti,Td, color)
  curve( getSim(kp,Ti,Td),color,sprintf("kp=%.2f, Ti=%.2f, Td=%.2f",kp,Ti,Td));

let o1 = nelderMead(targetMax,[0.7,1,1]);
let o2 = nelderMead(targetTime,o1.vec);

plot(
  getCurve(1.0,1.0,1.0,black),
  getCurve(o1.vec[0],o1.vec[1],o1.vec[2],blue),
  getCurve(o2.vec[0],o2.vec[1],o2.vec[2],red)
).xLabel("t").yLabel("h(t)").grid()</example>

</Examples>