<?xml version="1.0" encoding="UTF-8"?>
<Examples>
    <example name="Daten-Plot">let data = [
  [0, 0],
  [1, 1],
  [2, 4],
  [3, 9],
  [4,16]
];

plot(
 scatter( data )
)</example>
    <example name="Graph" desc="Funktionsplot">plot(
 function( x->sin(pi*x) )
)</example>
    <example name="Graph 2" desc="Funktionsplotter">plot(
 function( x->sin(pi*x), black, "sin(x)"),
 function( x->cos(pi*x), blue,  "cos(x)"),
 function( x->tan(pi*x), red,   "tan(x)")
).xBounds(0,2).yBounds(-2,2)</example>
    <example name="Ortskurve" desc="Darstellung der Ortskurve">let s = lin();
let g = 3/((s+1)*(s+2));

g.nyquist()</example>
    <example name="Ortskurve 2" desc="Darstellung der Ortskurve">let s = lin();
let g = 3/((s+1)*(s+1.5)*(s+2));

func h(w)
  let c1 = g( _i*w );
  let c2 = g( _i*w*0.99 );
  hintDir(c1.real(),c1.imag(),c2.real(),c2.imag(),"ω="+w);

g.nyquist()
  .add( h(0.1)  )
  .add( h(0.25) )
  .add( h(0.5)  )
  .add( h(1)    )
  .add( h(2)    )
  .add( h(5)    )</example>
    <example name="Nyquist" desc="Anwendung des Nyquistkriteriums">let s = lin();
let g = 6*(s+1)/((s-1)*(s-3));

g.nyquist(true)</example>
    <example name="Bode" desc="Darstellung eines Bode-Diagramms">let s = lin();
let g = 3/((s+1)*(s+2));

bode(0.01,100)
  .add(g)</example>
    <example name="Bode 2" desc="Darstellung mehrerer Kurven in einem Bode-Diagramm">let s = lin();
let g = 3/((s+1)*(s+2));
let k = 1.6*(1+1/(1.7*s));

let g0=k*g;
let pm=g0.pMargin();

bode(0.01,100)
  .add(g,  green, "G")
  .add(k,  blue,  "K")
  .add(g0, black, sprintf("G0, Φ=%.1f°, ω₀=%.2f rad/s",pm.pMargin,pm.w0) )
  .phaseModify( p->p.add(yConst(-180+70,red.dash(7,7)))
                    .add(yConst(-180+50,red.dash(7,7)))
                    .add(xConst(pm.w0,red.dash(7,7))) )
  .ampModify( p->p.add(xConst(pm.w0,red.dash(7,7))) )</example>
    <example name="pid" desc="Die pid-Funktion">[
 ["pid(2,2)",        "=", pid(2,2)  ],
 ["pid(2,3,1)",      "=", pid(2,3,1)],
 ["pid(2,3,1,0.01)", "=", pid(2,3,1,0.01)]
]</example>
    <example name="Evans" desc="Darstellung einer Wurzelortskurve">let s = lin();
let g = 3/((s+1)*(s+2));
let k = 1+1/(0.9*s);

(k*g).evans(2)</example>

    <example name="Evans 2" desc="Darstellung einer Wurzelortskurve">let l = 352*lin(poly(5,1),poly(0,0,2000,200,25,1));
l.evans(100)</example>

    <example name="Simulation" desc="Simulation des Systems">let s=lin();

let g = 70/((s+1)*(s+2)*(s+2.5));
let k1 = 0.2*(0.6*s+1)/(0.002*s+1);
let k2 = pid(0.1,2);
let k3 = pid(0.3,2,0.5);

plot(
  curve((k1*g).loop().simStep(10),blue,"phasenanhebendes Korrekturglied"),
  curve((k2*g).loop().simStep(10),black,"PI"),
  curve((k3*g).loop().simStep(10),green,"PID")
).labels("t [s]","h(t)").legendPos(5,0.87)</example>

<example name="Simulation nicht linear" desc="Simulation eines nicht linearen Systems">let s = lin();
let g = 70/((s+1)*(s+2)*(s+2.5));

let kp = 0.24;
let Ti = 1.05;
let Td = 0.82;
let Tp = 0.05;

// A Simulink-like model in the form of a simple netlist.
let systemDescription = [
 {              block: 1,                 out:"w"    },
 {in:["w","y"], block: "-",               out:"e"    },
 {in:"e",       block: pid(kp,Ti,Td,Tp),  out:"u"    },
 {in:"u",       block: blockLimiter(0,1), out:"uLim" },
 {in:"uLim",    block: g,                 out:"y"    }
];

let simLimited = simulate(systemDescription,6);
let simNormal  = (pid(kp,Ti,Td,Tp)*g).loop().simStep(6);

plot(
  curve(simNormal,       green, "y (u unlimited)" ),
  curve(simLimited.uLim, blue,  "u limited"       ),
  curve(simLimited.y,    black, "y (u limited)"   )
).yBounds(-0.2,1.5).grid()
 .legendPos(2,0.7)
 .labels("t [s]", "h(t)")
 .title("Effect of a Limiter")</example>
            <!--example name="Nelder&amp;Mead" desc="Nichtlineare Optimierung">let s=lin();
let g=7/((s+1)*(s+2)*(s-1));


func getSim(kp,T)
  let k=kp*(T*s+1)/(0.01*s+1);
  let g0=k*g;
  let k0=g0(0);
  let v=(1+k0)/k0;
  let vor=v*(g0.loop());
  vor.simStep(10);

const maxPercent=3;
const minStartTime=4;

const minBorder=1-maxPercent/100;
const maxBorder=1+maxPercent/100;

func targetMax(kp,T)
  let sim = getSim(kp,T);
  let ma=sim.minMax(e-&gt;e[1]).maxItem;
  let mi=sim.accept(e-&gt;e[0]&gt;minStartTime).minMax(e-&gt;e[1]).minItem;
  sqr(ma[1]-maxBorder)+sqr(mi[1]-minBorder);

const maxTimePercent=4;
const maxTimeDif = maxTimePercent/100;

func targetTime(kp,T)
  let sim=getSim(kp,T);
  let l = sim.combine((a,b)-&gt;{a:a,b:b}).accept(e-&gt;abs(e.a[1]-1)&gt;maxTimeDif &amp; abs(e.b[1]-1)&lt;=maxTimeDif).last();
  let bez = if l.a[1]&lt;1 then 1-maxTimeDif else 1+maxTimeDif;
  l.a[0]+(bez-l.a[1])/(l.b[1]-l.a[1])*(l.b[0]-l.a[0]);

func getCurve(kp,T, color)
  curve( getSim(kp,T),color,sprintf(&quot;kp=%.2f, Ti=%.2f, Tm=%.2f&quot;,kp,T,targetTime(kp,T)) );

let kp = 0.4;
let T = 1.1;

let o1 = nelderMead(targetMax,[kp,T]);
let o2 = nelderMead(targetTime,o1.vec);

plot(
  getCurve(kp,T,black),
  getCurve(o1.vec[0],o1.vec[1],blue),
  getCurve(o2.vec[0],o2.vec[1],red)
).xLabel(&quot;t&quot;).yLabel(&quot;h(t)&quot;).grid().legendPos(5,0.9)</example-->

</Examples>